{"history":[{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"effects":[],"size":0.748,"rotation":0,"height":1038,"fitToCanvas":false,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/Hero (15).png","translateX":2,"translateY":-1,"width":1920,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[{"max":null,"name":"Desktop","min":992,"props":{"frequency":1,"amount":0.07,"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4).png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","lady-map (4).png","uCustomTexture"],"mouseMomentum":0.43,"scale":0.37,"angle":0,"pos":{"type":"Vec2","_x":0.4872093023255814,"_y":0.5558889722430608},"speed":0.13}},{"min":576,"max":991,"props":{"scale":0.37,"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","uCustomTexture","https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","lady-map (4).png"]},"name":"Tablet"},{"props":{"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","uCustomTexture","https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","lady-map (4).png"]},"max":575,"min":0,"name":"Mobile"}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"custom","texture":{"src":"https://assets.unicorn.studio/images/JvyMwZcNgQfs53gbk8chlfW1W5D3/lady-map (4).png","thumb":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/JvyMwZcNgQfs53gbk8chlfW1W5D3%2Flady-map%20(4)_%40thumbnail.png?alt=media&token=effecc31-bbda-45ea-b6b1-9e2821beb077","name":"lady-map (4).png","sampler":"uCustomTexture"},"speed":0.13,"mouseMomentum":0.43,"animating":true,"isMask":0,"customFragmentShaders":["#version 300 es\nprecision mediump float;\n\n// Input texture coordinates from the vertex shader\nin vec2 vTextureCoord;\n\n// Define the uniforms\nuniform vec2 uResolution;     // width and height of the screen\nuniform vec2 uMousePos;       // mouse position\nuniform float uAmount;        // scale factor for the 3D effect intensity\nuniform sampler2D uTexture;   // main texture\nuniform sampler2D uCustomTexture; // depth map\n\n// Define the output color\nout vec4 fragColor;\n\n// Function to handle mirrored UVs\nvec2 mirrored(vec2 v) {\n  vec2 m = mod(v, 2.0);\n  return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvoid main() {\n  // Calculate aspect ratios\n  float textureAspectRatio = float(textureSize(uCustomTexture, 0).x) / float(textureSize(uCustomTexture, 0).y);\n  float windowAspectRatio = uResolution.x / uResolution.y;\n\n  // Determine the scaling factor and offsets\n  vec2 scale = vec2(1.0);\n  vec2 offset = vec2(0.0);\n\n  if (windowAspectRatio > textureAspectRatio) {\n    scale.y = textureAspectRatio / windowAspectRatio;\n    offset.y = (1.0 - scale.y) * 0.5;\n  } else {\n    scale.x = windowAspectRatio / textureAspectRatio;\n    offset.x = (1.0 - scale.x) * 0.5;\n  }\n\n  // Adjust and center the texture coordinates\n  vec2 adjustedUv = vTextureCoord * scale + offset;\n\n  // Get the texture from the depth map\n  vec4 depthMap = texture(uCustomTexture, mirrored(adjustedUv));\n\n  // Calculate the fake 3D offset with reduced movement\nvec2 offset3D = (depthMap.r - 0.5) * (uAmount * 0.05) * (uMousePos - vec2(0.5));\n\n  // Apply the fake 3D offset\n  vec2 fake3D = vTextureCoord + offset3D;\n\n  // Get the color from the main texture using the fake 3D coordinates\n  vec4 color = texture(uTexture, mirrored(fake3D));\n\n  // Set the output color of our pixel to the main texture color\n  fragColor = color;\n}\n\n"],"customVertexShaders":["#version 300 es\nprecision mediump float;\n\nin vec3 aVertexPosition;  // Vertex position input\nin vec2 aTextureCoord;    // Texture coordinates input\n\nout vec2 vTextureCoord;   // Pass texture coordinates to the fragment shader\n\nvoid main() {\n    // Set the position of the vertex in normalized device coordinates (NDC)\n    gl_Position = vec4(aVertexPosition, 1.0);\n\n    // Pass the texture coordinates to the fragment shader\n    vTextureCoord = aTextureCoord;\n}\n"],"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uTexture; uniform sampler2D uCustomTexture;out vec4 fragColor;vec2 mirrored(vec2 v) { vec2 m = mod(v, 2.0); return mix(m, 2.0 - m, step(1.0, m)); }void main() { float textureAspectRatio = float(textureSize(uCustomTexture, 0).x) / float(textureSize(uCustomTexture, 0).y); float windowAspectRatio = uResolution.x / uResolution.y; vec2 scale = vec2(1.0); vec2 offset = vec2(0.0);if (windowAspectRatio > textureAspectRatio) { scale.y = textureAspectRatio / windowAspectRatio; offset.y = (1.0 - scale.y) * 0.5; } else { scale.x = windowAspectRatio / textureAspectRatio; offset.x = (1.0 - scale.x) * 0.5; } vec2 adjustedUv = vTextureCoord * scale + offset; vec4 depthMap = texture(uCustomTexture, mirrored(adjustedUv)); vec2 offset3D = (depthMap.r - 0.5) * (0.07 * 0.05) * (uMousePos - vec2(0.5)); vec2 fake3D = vTextureCoord + offset3D; vec4 color = texture(uTexture, mirrored(fake3D)); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord;void main() { gl_Position = vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{"scale":{"name":"uScale","type":"1f","value":0.5}}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"spotlight","intensity":0.02,"trackMouse":1,"mouseMomentum":0,"animating":false,"isMask":0,"states":{"appear":[],"scroll":[],"hover":[{"type":"hover","id":"605e1d7d-c030-47eb-a5c9-148e8f6818be","prop":"intensity","transition":{"ease":"easeInOutQuart","duration":1000,"delay":0},"progress":0,"rawProgress":0,"lastProgress":null,"value":0.32,"uniformData":{"type":"1f","name":"uIntensity"}}]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (1.00 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(1, 0)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (1.00 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(0, 1)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;uniform float uIntensity;out vec4 fragColor;const int kernelSize = 36;float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return col.r; }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 1.00) / ste, 2.)), height); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }vec4 getPointlight(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec4 color = texture(uBgTexture, uv); float luma = color.r; float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.76 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.76 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb*luma; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = uIntensity * 3.; vec3 base = color.rgb * vec3(1, 0.8196078431372549, 0.596078431372549) * max(0., spot) * intensity; color.rgb = color.rgb * 1.00 + base * diff * vec3(1, 0.8196078431372549, 0.596078431372549) * max(0., spot) * intensity; color.rgb += specular * vec3(1, 0.8196078431372549, 0.596078431372549) * max(0., spot * 4.) * 0.25; color.rgb = Tonemap_tanh(color.rgb); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 getColor(vec2 uv) { return getPointlight(uv); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"passes":[{"prop":"pass","value":1},{"prop":"pass","value":2,"includeBg":true}]}}],"options":{"name":"Copy of Untitled project (3)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.3.2","id":"G6p3mGCUmbJ6TsWOgZjD"}
